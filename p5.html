<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script>
      let activeLines = [];
      let maxLength = 200;
      let touchToLineMap = new Map(); // Map to track which touch created which line
      let colorPairs; // Declare the variable globally
      
      function setup() {
        createCanvas(windowWidth, windowHeight);
        angleMode(RADIANS);
        background(0);
        
        // Define color pairs
        colorPairs = [
          [color(0, 120, 255), color(255, 50, 50)],     // blue to red
          [color(255, 50, 50), color(255, 255, 0)],     // red to yellow
          [color(255, 255, 0), color(0, 120, 255)],     // yellow to blue
          [color(255, 0, 255), color(0, 255, 255)],     // magenta to cyan
          [color(255, 165, 0), color(128, 0, 128)],     // orange to purple
          [color(0, 255, 0), color(255, 0, 255)]        // green to magenta
        ];
      }

      function draw() {
        background(0);
        
        // Draw all active lines
        for (let lineData of activeLines) {
          let duration = millis() - lineData.startTime;
          let lineLength;
          
          if (lineData.growing) {
            // Make line grow indefinitely, speed based on force
            let growthSpeed = map(lineData.force || 0.5, 0, 1, 0.2, 1.5); // Default to 0.5 if force not available
            lineLength = map(duration, 0, 1000, 20, maxLength, true) * growthSpeed;
            if (duration > 1000) {
              // After reaching maxLength, continue growing beyond it
              lineLength = maxLength + (duration - 1000) * 0.5 * growthSpeed;
            }
          } else {
            lineLength = lineData.finalLength;
          }

          // Color: interpolate between the selected color pair
          let colorPair = lineData.colorPair;
          let amt = (cos(lineLength * 0.002) + 1) / 2;
          let col = lerpColor(colorPair[0], colorPair[1], amt);

          // Calculate points for both ends
          let halfLength = lineLength / 2;
          let x1 = lineData.x - halfLength * cos(lineData.angle);
          let y1 = lineData.y - halfLength * sin(lineData.angle);
          let x2 = lineData.x + halfLength * cos(lineData.angle);
          let y2 = lineData.y + halfLength * sin(lineData.angle);

          // Draw line
          push();
          // Draw outer glow
          for (let i = 0; i < 4; i++) {
            stroke(red(col), green(col), blue(col), 60 - i * 12);
            strokeWeight(12 - i * 2);
            line(x1, y1, x2, y2);
          }
          // Draw main line
          stroke(col);
          strokeWeight(4);
          line(x1, y1, x2, y2);
          // Draw inner glow
          stroke(255, 255, 255, 150);
          strokeWeight(2);
          line(x1, y1, x2, y2);
          pop();
        }
      }

      function touchStarted() {
        // Add new line for each touch
        for (let touch of touches) {
          // Check if this touch already has a line
          if (!touchToLineMap.has(touch.id)) {
            let newLine = {
              x: touch.x,
              y: touch.y,
              startTime: millis(),
              angle: random(TWO_PI),
              growing: true,
              finalLength: 0,
              force: touch.force || 0.5,
              touchId: touch.id, // Store the touch ID
              colorPair: colorPairs[floor(random(colorPairs.length))] // Properly randomize color pair
            };
            activeLines.push(newLine);
            touchToLineMap.set(touch.id, newLine);
          }
        }
        return false;
      }

      function touchMoved() {
        // Update force for existing touches
        for (let touch of touches) {
          let lineData = touchToLineMap.get(touch.id);
          if (lineData && lineData.growing) {
            lineData.force = touch.force || 0.5;
          }
        }
        return false;
      }

      function touchEnded() {
        // Stop growing for ended touches
        for (let touch of touches) {
          let lineData = touchToLineMap.get(touch.id);
          if (lineData && lineData.growing) {
            let duration = millis() - lineData.startTime;
            if (duration > 1000) {
              lineData.finalLength = maxLength + (duration - 1000) * 0.5;
            } else {
              lineData.finalLength = map(duration, 0, 1000, 20, maxLength, true);
            }
            lineData.growing = false;
          }
          touchToLineMap.delete(touch.id);
        }
        return false;
      }

      // Optional: Support mouse for desktop testing
      function mousePressed() {
        activeLines.push({
          x: mouseX,
          y: mouseY,
          startTime: millis(),
          angle: random(TWO_PI),
          growing: true,
          finalLength: 0,
          force: 0.5, // Default force for mouse
          colorPair: colorPairs[floor(random(colorPairs.length))], // Properly randomize color pair
          reversed: random() < 0.5 // Randomly reverse the color direction
        });
        return false;
      }

      function mouseReleased() {
        // Stop growing for all active lines
        for (let lineData of activeLines) {
          if (lineData.growing) {
            let duration = millis() - lineData.startTime;
            if (duration > 1000) {
              lineData.finalLength = maxLength + (duration - 1000) * 0.5;
            } else {
              lineData.finalLength = map(duration, 0, 1000, 20, maxLength, true);
            }
            lineData.growing = false;
          }
        }
        return false;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        background(0);
      }
    </script>
  </body>
</html>
