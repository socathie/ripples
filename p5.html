<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script>
      let activeLines = [];
      let maxLength = 200;
      let touchToLineMap = new Map(); // Map to track which touch created which line

      function setup() {
        createCanvas(windowWidth, windowHeight);
        angleMode(RADIANS);
        background(0);
      }

      function draw() {
        background(0);
        
        // Draw all active lines
        for (let lineData of activeLines) {
          let duration = millis() - lineData.startTime;
          let lineLength;
          
          if (lineData.growing) {
            // Make line grow indefinitely, speed based on force
            let growthSpeed = map(lineData.force || 0.5, 0, 1, 0.2, 1.5); // Default to 0.5 if force not available
            lineLength = map(duration, 0, 1000, 20, maxLength, true) * growthSpeed;
            if (duration > 1000) {
              // After reaching maxLength, continue growing beyond it
              lineLength = maxLength + (duration - 1000) * 0.5 * growthSpeed;
            }
          } else {
            lineLength = lineData.finalLength;
          }

          // Color: blue to red based on length
          let c1 = color(0, 120, 255);
          let c2 = color(255, 50, 50);
          let amt = (cos(lineLength * 0.002) + 1) / 2;
          let col = lerpColor(c1, c2, amt);

          // Calculate points for both ends
          let halfLength = lineLength / 2;
          let x1 = lineData.x - halfLength * cos(lineData.angle);
          let y1 = lineData.y - halfLength * sin(lineData.angle);
          let x2 = lineData.x + halfLength * cos(lineData.angle);
          let y2 = lineData.y + halfLength * sin(lineData.angle);

          // Draw line
          push();
          stroke(col);
          strokeWeight(4);
          line(x1, y1, x2, y2);
          pop();
        }
      }

      function touchStarted() {
        // Add new line for each touch
        for (let touch of touches) {
          // Check if this touch already has a line
          if (!touchToLineMap.has(touch.id)) {
            let newLine = {
              x: touch.x,
              y: touch.y,
              startTime: millis(),
              angle: random(TWO_PI),
              growing: true,
              finalLength: 0,
              force: touch.force || 0.5,
              touchId: touch.id // Store the touch ID
            };
            activeLines.push(newLine);
            touchToLineMap.set(touch.id, newLine);
          }
        }
        return false;
      }

      function touchMoved() {
        // Update force for existing touches
        for (let touch of touches) {
          let lineData = touchToLineMap.get(touch.id);
          if (lineData && lineData.growing) {
            lineData.force = touch.force || 0.5;
          }
        }
        return false;
      }

      function touchEnded() {
        // Stop growing for ended touches
        for (let touch of touches) {
          let lineData = touchToLineMap.get(touch.id);
          if (lineData && lineData.growing) {
            let duration = millis() - lineData.startTime;
            if (duration > 1000) {
              lineData.finalLength = maxLength + (duration - 1000) * 0.5;
            } else {
              lineData.finalLength = map(duration, 0, 1000, 20, maxLength, true);
            }
            lineData.growing = false;
          }
          touchToLineMap.delete(touch.id);
        }
        return false;
      }

      // Optional: Support mouse for desktop testing
      function mousePressed() {
        activeLines.push({
          x: mouseX,
          y: mouseY,
          startTime: millis(),
          angle: random(TWO_PI),
          growing: true,
          finalLength: 0,
          force: 0.5 // Default force for mouse
        });
        return false;
      }

      function mouseReleased() {
        // Stop growing for all active lines
        for (let lineData of activeLines) {
          if (lineData.growing) {
            let duration = millis() - lineData.startTime;
            if (duration > 1000) {
              lineData.finalLength = maxLength + (duration - 1000) * 0.5;
            } else {
              lineData.finalLength = map(duration, 0, 1000, 20, maxLength, true);
            }
            lineData.growing = false;
          }
        }
        return false;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        background(0);
      }
    </script>
  </body>
</html>
